# **Aura Helper Package Generator Module**
Aura Helper Package Generator Module contains a powerfull class to create and merge package files to deploy, retrieve or delete metadata from your Salesforce's projects.

You can choose to merge several package xml files (including destructiveChanges.xml and destructiveChangesPost.xml files) to combine into one file of each type, combine all packages in one file and all detructives in another file or merge all files into one package or destructive file.

Also you can create packages XML files from a JSON file (See [Metadata JSON Format](#metadata-file) section). Use Aura Helper Metadata Factory [@ah/metadata-factory](https://github.com/JJLongoria/aura-helper-metadata-factory) to help to you to create the JSON file from a project in your computer ([@ah/metadata-factory](https://github.com/JJLongoria/aura-helper-metadata-factory)) or download metadata using Aura Helper Connector [@ah/connetor](https://github.com/JJLongoria/aura-helper-connector) to download it

To handle the JSON file types better, you can use MetadataType, MetadataObject and MetadataItem classes from [@ah/core](https://github.com/JJLongoria/aura-helper-core) > Types. Also you can use this classes to create your own JSON file and use the validateJSON() method to check if the file is correct.

Other **important and usefull** feature is the Ignore Metadata option. You can create an .ahignore.json file (see [Ignore File](#ignore-file) section) to ignore the specified metadata on the file and exclude from the package to avoid deploy, delete or retrieve the metadata files. This Feature is util in some use cases, like Custom Label values unique for every environment (like ids...), or to avoid deploy some user permissions, or when you creating autogenerated package (from git for example) and like to exclude some metadata automatically.

---

## *Table of Contents*

- [**PackageGenerator Class**](#packagegenerator-class)

- [**Ignore metadata from your package**](#ignore-metadata-from-your-package)

- [**Metadata JSON Format**](#metadata-json-format)
  
- [**Ignore File**](#ignore-file)

---

# [**PackageGenerator Class**](#packagegenerator-class)
Class to create and merge package files to deploy, retrieve or delete metadata from your Salesforce's projects.

Can merge several package xml files (including destructiveChanges.xml and destructiveChangesPost.xml files) to combine into one file of each type, combine all packages in one file and all detructives in another file or merge all files into one package or destructive file.

The file names must contains at least the "package" word to identify the package XML files and destructiveChanges or destrutiveChangesPost to the destructive files. For example: package1.xml, destructiveChanges_uat.xml, destructiveChangesPost-v34...

You can choose a custom API Version to create the packages, if not specified API version, the package generator get the higher API version from each file types, that is, for package XML files, get the higher API of the Package XML files passed, and the same with other file types.

# [**Methods**](#packagegenerator-class-methods)

  - [**options()**](#options)

    Method to get the default package generator options.

  - [**mergePackages(packageOrDestructiveFiles, outputFolder, options)**](#mergepackagespackageordestructivefiles-outputfolder-options)

    Method to merge several package xml files (including destructiveChanges.xml and destructiveChangesPost.xml files) to combine into one file of each type, combine all packages in one file and all detructives in another file.

  - [**mergePackagesFull(packageOrDestructiveFiles, outputFolder, options)**](#mergepackagesfullpackageordestructivefiles-outputfolder-options)
  
    Method to merge all provided files into only one file. You can choose if merge all into a package.xml, destructiveChanges.xml or destructiveChangesPost.xml

  - [**getPackageContent(metadataOrPath, options)**](#getpackagecontentmetadataorpath-options)

    Method to get the Package XML format content as String to the selected Metadata JSON file or Metadata JSON Object

  - [**createPackage(metadataOrPath, outputFolder, options)**](#createpackagemetadataorpath-outputfolder-options)

    Method to create a package XML file with the selected Metadata JSON file or Metadata JSON Object

  - [**createBeforeDeployDestructive(metadataOrPath, outputFolder, options)**](#createbeforedeploydestructivemetadataorpath-outputfolder-options)

    Method to create a before deploy destructive file with the selected Metadata JSON file or Metadata JSON Object

  - [**createAfterDeployDestructive(metadataOrPath, outputFolder, options)**](#createafterdeploydestructivemetadataorpath-outputfolder-options)

    Method to create an after deploy destructive file with the selected Metadata JSON file or Metadata JSON Object

  - [**validateJSON(metadataOrPath)**](#validatejsonmetadataorpath)

    Method to validate a Metadata JSON file or Metadata JSON Object format. If is not valid, throw several exceptions.
--- 

## [**options()**](#options)
Method to get the default package generator options. The available options are:
- **apiVersion**: Api version to create the package. If not provided use the latest api version of the provided files
- **mergePackages**: true if want to merge the provided package files
- **mergeDestructives**: true if want to merge the provided destructive files into one single file
- **isDestructive**: true if you want to merge all files into one destructive file (valid option to merge packages full) 
- **beforeDeploy**: true if want to merge destructive files into before deploy destructive file when select mergeDestructives
- **explicit**: true if you want to put all metadata types explicit into the file, false to use wildcards when are all checked
- **ignoreFile**: path to the ignore file to ignore some metadata types from the packages
- **typesToIgnore**: Object with the Metadata Types and Object to ignore, if exists on ignore file and not ignore the rest of the elements of the file

### **Return:**
Returns a PackageGeneratorOptions object with the default values. 
- PackageGeneratorOptions

The default values are:

    apiVersion: undefined
    mergePackages: true
    mergeDestructives: false
    isDestructive: false
    beforeDeploy: false
    explicit: true
    ignoreFile: undefined
    typesToIgnore: undefined

---
## [**mergePackages(packageOrDestructiveFiles, outputFolder, options)**](#mergepackagespackageordestructivefiles-outputfolder-options)
Method to merge several package xml files (including destructiveChanges.xml and destructiveChangesPost.xml files) to combine into one file of each type, combine all packages in one file and all detructives in another file.

### **Parameters:**
  - **packageOrDestructiveFiles**: File or list of files to merge (including package and destructive files in the same list)
    - String | Array\<String\> 
  - **outputFolder**: Folder to save the created files
    - String
  - **options**: Package Generator options to choose the options to merge
    - PackageGeneratorOptions

### **Return:**
Object with the merge result including the paths of the merged files
- PackageGeneratorResult

### **Throws:**
This method can throw the next exceptions:

- **WrongDatatypeException**: If api version is not a String or number (can be undefined)
- **DataNotFoundException**: If not package or destructive files provided
- **WrongFilePathException**: If the package or destructive files path is not a String or cant convert to absolute path
- **FileNotFoundException**: If the package or destructive files path not exists or not have access to it
- **InvalidFilePathException**: If the package or destructive files path is not a file
- **WrongDirectoryPathException**: If the output Folder is not a String or cant convert to absolute path
- **DirectoryNotFoundException**: If the directory not exists or not have access to it
- **InvalidDirectoryPathException**: If the path is not a directory

### **Examples:**
You have several options to merge package files: 

**Merge files by Type**

Merge all package XML file into one package XML file, merge all destructive changes pre deployment into one destructiveChanges XML and merge all destructive changes post deployment into one destructiveChangesPost XML.

    const PackageGenerator = require('@ah/package-generator');
    const filePaths = [
        '/test/package/package1.xml',                       // package.xml
        '/test/package/package2.xml',                       // package.xml
        '/test/package/package3.xml',                       // package.xml
        '/test/package/destructiveChanges-dev.xml',         // destructiveChanges.xml
        '/test/package/destructiveChanges-uat.xml',         // destructiveChanges.xml
        '/test/package/destructiveChangesPost1.xml',        // destructiveChangesPost.xml
        '/test/package/destructiveChangesPost-v34.xml'      // destructiveChangesPost.xml
        '/test/package/destructiveChangesPostCustom.xml'    // destructiveChangesPost.xml
    ];
    const outputFolder = 'path/to/the/output/folder';

    const result = PackageGenerator.mergePackages(filePaths, outputFolder); // Return an object with the full path of the created files;

    console.log(result.package);                    // [pathFromRoot]/path/to/the/output/folder/package.xml
    console.log(result.destructiveChanges);         // [pathFromRoot]/path/to/the/output/folder/destructiveChanges.xml
    console.log(result.destructiveChangesPost);     // [pathFromRoot]/path/to/the/output/folder/destructiveChangesPost.xml

**Merge all destructive XML files post deployment**

Merge all package XML file into one package XML file and merge all destructive changes pre and post deployment into one destructiveChanges XML post deployment. 

    const PackageGenerator = require('@ah/package-generator');
    const filePaths = [
        '/test/package/package1.xml',                       // package.xml
        '/test/package/package2.xml',                       // package.xml
        '/test/package/package3.xml',                       // package.xml
        '/test/package/destructiveChanges-dev.xml',         // destructiveChanges.xml
        '/test/package/destructiveChanges-uat.xml',         // destructiveChanges.xml
        '/test/package/destructiveChangesPost1.xml',        // destructiveChangesPost.xml
        '/test/package/destructiveChangesPost-v34.xml'      // destructiveChangesPost.xml
        '/test/package/destructiveChangesPostCustom.xml'    // destructiveChangesPost.xml
    ];
    const outputFolder = 'path/to/the/output/folder';
    const options = {
        apiVersion: '50.0',     // Optional for merge packages because get api version from XML files. (if XML files has no version, apiVersion is required)
        mergeDestructives: true
    }
    const result = PackageGenerator.mergePackages(filePaths, outputFolder, options); // Return an object with the full path of the created files;
    
    console.log(result.package);                    // [pathFromRoot]/path/to/the/output/folder/package.xml
    console.log(result.destructiveChanges);         // undefined    (By default, create destructives after deploy)
    console.log(result.destructiveChangesPost);     // [pathFromRoot]/path/to/the/output/folder/destructiveChangesPost.xml

**Merge all destructive XML files pre deployment**

Merge all package XML file into one package XML file and merge all destructive changes pre and post deployment into one destructiveChanges XML pre deployment.

    const PackageGenerator = require('@ah/package-generator');
    const filePaths = [
        '/test/package/package1.xml',                       // package.xml
        '/test/package/package2.xml',                       // package.xml
        '/test/package/package3.xml',                       // package.xml
        '/test/package/destructiveChanges-dev.xml',         // destructiveChanges.xml
        '/test/package/destructiveChanges-uat.xml',         // destructiveChanges.xml
        '/test/package/destructiveChangesPost1.xml',        // destructiveChangesPost.xml
        '/test/package/destructiveChangesPost-v34.xml'      // destructiveChangesPost.xml
        '/test/package/destructiveChangesPostCustom.xml'    // destructiveChangesPost.xml
    ];
    const outputFolder = 'path/to/the/output/folder';
    const options = {
        apiVersion: '50.0',     // Optional for merge packages because get api version from XML files. (if XML files has no version, apiVersion is required)
        mergeDestructives: true,
        beforeDeploy = true;
    }
    const result = PackageGenerator.mergePackages(filePaths, outputFolder, options); // Return an object with the full path of the created files;
    
    console.log(result.package);                    // [pathFromRoot]/path/to/the/output/folder/package.xml
    console.log(result.destructiveChanges);         // [pathFromRoot]/path/to/the/output/folder/destructiveChanges.xml
    console.log(result.destructiveChangesPost);     // undefined
---
## [**mergePackagesFull(packageOrDestructiveFiles, outputFolder, options)**](#mergepackagesfullpackageordestructivefiles-outputfolder-options)
Method to merge all provided files into only one file. You can choose if merge all into a package.xml, destructiveChanges.xml or destructiveChangesPost.xml

### **Parameters:**
  - **packageOrDestructiveFiles**: File or list of files to merge (including package and destructive files in the same list)
    - String | Array\<String\> 
  - **outputFolder**: Folder to save the created files
    - String
  - **options**: Package Generator options to choose the options to merge
    - PackageGeneratorOptions

### **Return:**
Object with the merge result including the paths of the merged files
- PackageGeneratorResult

### **Throws:**
This method can throw the next exceptions:

- **WrongDatatypeException**: If api version is not a String or number (can be undefined)
- **DataNotFoundException**: If not package or destructive files provided
- **WrongFilePathException**: If the package or destructive files path is not a String or cant convert to absolute path
- **FileNotFoundException**: If the package or destructive files path not exists or not have access to it
- **InvalidFilePathException**: If the package or destructive files path is not a file
- **WrongDirectoryPathException**: If the output Folder is not a String or cant convert to absolute path
- **DirectoryNotFoundException**: If the directory not exists or not have access to it
- **InvalidDirectoryPathException**: If the path is not a directory

### **Examples:**
You have several options to merge full package files: 

**Full Merge into Package XML**

Merge all package XML, all destructiveChanges XML and all destructiveChangesPost XML files into one package XML file.

    const PackageGenerator = require('@ah/package-generator');
    const filePaths = [
        '/test/package/package1.xml',                       // package.xml
        '/test/package/package2.xml',                       // package.xml
        '/test/package/package3.xml',                       // package.xml
        '/test/package/destructiveChanges-dev.xml',         // destructiveChanges.xml
        '/test/package/destructiveChanges-uat.xml',         // destructiveChanges.xml
        '/test/package/destructiveChangesPost1.xml',        // destructiveChangesPost.xml
        '/test/package/destructiveChangesPost-v34.xml'      // destructiveChangesPost.xml
        '/test/package/destructiveChangesPostCustom.xml'    // destructiveChangesPost.xml
    ];
    const outputFolder = 'path/to/the/output/folder';
    const options = {
        apiVersion: '50.0',     // Optional for merge packages because get api version from XML files. (if XML files has no version, apiVersion is required)
    }

    const result = PackageGenerator.mergePackagesFull(filePaths, outputFolder, options); // Return an object with the full path of the created files;
    
    console.log(result.package);                    // [pathFromRoot]/path/to/the/output/folder/package.xml
    console.log(result.destructiveChanges);         // undefined
    console.log(result.destructiveChangesPost);     // undefined

**Full Merge into Destructive XML post deployment**

Merge all package XML, all destructiveChanges XML and all destructiveChangesPost XML files into one destructiveChangesPost XML file.

    const PackageGenerator = require('@ah/package-generator');
    const filePaths = [
        '/test/package/package1.xml',                       // package.xml
        '/test/package/package2.xml',                       // package.xml
        '/test/package/package3.xml',                       // package.xml
        '/test/package/destructiveChanges-dev.xml',         // destructiveChanges.xml
        '/test/package/destructiveChanges-uat.xml',         // destructiveChanges.xml
        '/test/package/destructiveChangesPost1.xml',        // destructiveChangesPost.xml
        '/test/package/destructiveChangesPost-v34.xml'      // destructiveChangesPost.xml
        '/test/package/destructiveChangesPostCustom.xml'    // destructiveChangesPost.xml
    ];
    const outputFolder = 'path/to/the/output/folder';
    const options = {
        apiVersion: '50.0',     // Optional for merge packages because get api version from XML files. (if XML files has no version, apiVersion is required)
        isDestructive: true,
    }

    const result = PackageGenerator.mergePackagesFull(filePaths, outputFolder, apiVersion, isDestructive); // Return an object with the full path of the created files;
    
    console.log(result.package);                    // undefined
    console.log(result.destructiveChanges);         // undefined        (By default, create destructives after deploy)
    console.log(result.destructiveChangesPost);     // [pathFromRoot]/path/to/the/output/folder/destructiveChangesPost.xml

**Full Merge into Destructive XML pre deployment**

Merge all package XML, all destructiveChanges XML and all destructiveChangesPost XML files into one destructiveChanges XML file.

    const PackageGenerator = require('@ah/package-generator');
    const filePaths = [
        '/test/package/package1.xml',                       // package.xml
        '/test/package/package2.xml',                       // package.xml
        '/test/package/package3.xml',                       // package.xml
        '/test/package/destructiveChanges-dev.xml',         // destructiveChanges.xml
        '/test/package/destructiveChanges-uat.xml',         // destructiveChanges.xml
        '/test/package/destructiveChangesPost1.xml',        // destructiveChangesPost.xml
        '/test/package/destructiveChangesPost-v34.xml'      // destructiveChangesPost.xml
        '/test/package/destructiveChangesPostCustom.xml'    // destructiveChangesPost.xml
    ];
    const outputFolder = 'path/to/the/output/folder';
    const options = {
        apiVersion: '50.0',            // Optional for merge packages
        isDestructive: true,
        beforeDeploy: true
    }
    const result = PackageGenerator.mergePackagesFull(filePaths, outputFolder, apiVersion, isDestructive, beforeDeploy); // Return an object with the full path of the created files;
    
    console.log(result.package);                    // undefined
    console.log(result.destructiveChanges);         // [pathFromRoot]/path/to/the/output/folder/destructiveChanges.xml
    console.log(result.destructiveChangesPost);     // undefined
---
## [**getPackageContent(metadataOrPath, options)**](#getpackagecontentmetadataorpath-options)
Method to get the Package XML format content as String to the selected Metadata JSON file or Metadata JSON Object. See [Metadata JSON Format](#metadata-file) section to understand the JSON Metadata File.

### **Parameters:**
  - **metadataOrPath**: Metadata JSON file or Metadata JSON object to get the package or destructive XML content.
    - String | Object
  - **options**: Package Generator options to choose the options to get the package content
    - PackageGeneratorOptions

### **Return:**
Returns an String with the XML content
- String

### **Throws:**
This method can throw the next exceptions:

- **WrongDatatypeException**: If api version is not a String or number (can be undefined)
- **WrongFilePathException**: If the package or destructive files path is not a String or cant convert to absolute path
- **FileNotFoundException**: If the package or destructive files path not exists or not have access to it
- **InvalidFilePathException**: If the package or destructive files path is not a file
- **WrongDirectoryPathException**: If the output Folder is not a String or cant convert to absolute path
- **DirectoryNotFoundException**: If the directory not exists or not have access to it
- **InvalidDirectoryPathException**: If the path is not a directory
- **WrongFormatException**: If file is not a JSON file or not have the correct Metadata JSON format

### **Examples:**
You have several options to get Package XML Content: 

**Get the package XML Content from Metadata JSON File**

    const PackageGenerator = require('@ah/package-generator');
    const jsonFilePath = 'path/to/json/metadata.json';
    const options = {
        apiVersion: '50.0',      // Required for create Package from JSON
        explicit: true,          // true to put all element names explicit in package, false to use wildcards if apply. (recommended explicit=true)
    }

    const xmlResultFromFile = PackageGenerator.getPackageContent(jsonFilePath, options);

    console.log(xmlResultFromFile);                    // <?xml version="1.0" encoding="UTF-8"?>
                                                       // <Package xmlns="http://soap.sforce.com/2006/04/metadata">
                                                       // ...


**Get the package XML Content from Metadata JSON Object**

    const PackageGenerator = require('@ah/package-generator');
    const jsonFilePath = 'path/to/json/metadata.json';
    const options = {
        apiVersion: '50.0',      // Required for create Package from JSON
        explicit: true,          // true to put all element names explicit in package, false to use wildcards if apply. (recommended explicit=true)
    }

    const jsonContent = JSON.parse(fs.readFileSync(jsonFilePath, 'utf8'));
    const xmlResultFromJSON = PackageGenerator.getPackageContent(jsonContent, options);

    console.log(xmlResultFromJSON);                    // <?xml version="1.0" encoding="UTF-8"?>
                                                       // <Package xmlns="http://soap.sforce.com/2006/04/metadata">
                                                       // ...
---
## [**createPackage(metadataOrPath, outputFolder, options)**](#createpackagemetadataorpath-outputfolder-options)
Method to create a package XML file with the selected Metadata JSON file or Metadata JSON Object. See [Metadata JSON Format](#metadata-file) section to understand the JSON Metadata File.

### **Parameters:**
  - **metadataOrPath**: Metadata JSON file or Metadata JSON object to create the package file.
    - String | Object
  - **outputFolder**: Folder to save the created file
    - String
  - **options**: Package Generator options to choose the options to get the package content
    - PackageGeneratorOptions

### **Return:**
Returns the path to the created file
- String

### **Throws:**
This method can throw the next exceptions:

- **WrongDatatypeException**: If api version is not a String or number (can be undefined)
- **WrongFilePathException**: If the package or destructive files path is not a String or cant convert to absolute path
- **FileNotFoundException**: If the package or destructive files path not exists or not have access to it
- **InvalidFilePathException**: If the package or destructive files path is not a file
- **WrongDirectoryPathException**: If the output Folder is not a String or cant convert to absolute path
- **DirectoryNotFoundException**: If the directory not exists or not have access to it
- **InvalidDirectoryPathException**: If the path is not a directory
- **WrongFormatException**: If file is not a JSON file or not have the correct Metadata JSON format

### **Examples:**
You have several options to create the XML Package file: 

**Create Package XML from Metadata JSON File**

    const PackageGenerator = require('@ah/package-generator');
    
    const jsonFilePath = 'path/to/json/metadata.json';
    const outputFolder = 'path/to/the/output/folder';
    const options = {
        apiVersion: '50.0',      // Required for create Package from JSON
        explicit: true,          // true to put all element names explicit in package, false to use wildcards if apply. (recommended explicit=true)
    }

    const packageFromFileResult = PackageGenerator.createPackage(jsonFilePath, outputFolder, options);

    console.log(packageFromFileResult);            // [rootPath]/path/to/json/package.xml

**Create Package XML from Metadata JSON Object**

    const PackageGenerator = require('@ah/package-generator');
    
    const jsonFilePath = 'path/to/json/metadata.json';
    const outputFolder = 'path/to/the/output/folder';
    const options = {
        apiVersion: '50.0',      // Required for create Package from JSON
        explicit: true,          // true to put all element names explicit in package, false to use wildcards if apply. (recommended explicit=true)
    }

    const jsonContent = JSON.parse(fs.readFileSync('jsonFilePath', 'utf8'));
    const packageFromJSONObjectResult = PackageGenerator.createPackage(jsonContent, outputFolder, options);

    console.log(packageFromJSONObjectResult);        // [rootPath]/path/to/json/package.xml
---
## [**createBeforeDeployDestructive(metadataOrPath, outputFolder, options)**](#createbeforedeploydestructivemetadataorpath-outputfolder-options)
Method to create a before deploy destructive file with the selected Metadata JSON file or Metadata JSON Object. See [Metadata JSON Format](#metadata-file) section to understand the JSON Metadata File.

### **Parameters:**
  - **metadataOrPath**: Metadata JSON file or Metadata JSON object to create the destructive file.
    - String | Object
  - **outputFolder**: Folder to save the created file
    - String
  - **options**: Package Generator options to choose the options to get the package content
    - PackageGeneratorOptions

### **Return:**
Returns the path to the created file
- String

### **Throws:**
This method can throw the next exceptions:

- **WrongDatatypeException**: If api version is not a String or number (can be undefined)
- **WrongFilePathException**: If the package or destructive files path is not a String or cant convert to absolute path
- **FileNotFoundException**: If the package or destructive files path not exists or not have access to it
- **InvalidFilePathException**: If the package or destructive files path is not a file
- **WrongDirectoryPathException**: If the output Folder is not a String or cant convert to absolute path
- **DirectoryNotFoundException**: If the directory not exists or not have access to it
- **InvalidDirectoryPathException**: If the path is not a directory
- **WrongFormatException**: If file is not a JSON file or not have the correct Metadata JSON format

### **Examples:**
You have several options to create the XML before destructive file: 

**Create Destructive Changes XML before deploy from Metadata JSON File**

    const PackageGenerator = require('@ah/package-generator');
    const jsonFilePath = 'path/to/json/metadata.json';
    const outputFolder = 'path/to/the/output/folder';
    const options = {
        apiVersion: '50.0',      // Required for create Package from JSON
        explicit: true,          // true to put all element names explicit in package, false to use wildcards if apply. (recommended explicit=true)
    }

    const packageFromFileResult = PackageGenerator.createBeforeDeployDestructive(jsonFilePath, outputFolder, options);

    console.log(packageFromFileResult);          // [rootPath]/path/to/json/destructiveChanges.xml

**Create Destructive Changes XML before deploy from Metadata JSON Object**

    const PackageGenerator = require('@ah/package-generator');
    const jsonFilePath = 'path/to/json/metadata.json';
    const outputFolder = 'path/to/the/output/folder';
    const options = {
        apiVersion: '50.0',      // Required for create Package from JSON
        explicit: true,          // true to put all element names explicit in package, false to use wildcards if apply. (recommended explicit=true)
    }

    const jsonContent = JSON.parse(fs.readFileSync('jsonFilePath', 'utf8'));
    const packageFromJSONObjectResult = PackageGenerator.createBeforeDeployDestructive(jsonContent, outputFolder, options);

    console.log(packageFromJSONObjectResult);          // [rootPath]/path/to/json/destructiveChanges.xml
---

## [**createAfterDeployDestructive(metadataOrPath, outputFolder, options)**](#createafterdeploydestructivemetadataorpath-outputfolder-options)
Method to create an after deploy destructive file with the selected Metadata JSON file or Metadata JSON Object. See [Metadata JSON Format](#metadata-file) section to understand the JSON Metadata File.

### **Parameters:**
  - **metadataOrPath**: Metadata JSON file or Metadata JSON object to create the destructive file.
    - String | Object
  - **outputFolder**: Folder to save the created file
    - String
  - **options**: Package Generator options to choose the options to get the package content
    - PackageGeneratorOptions

### **Return:**
Returns the path to the created file
- String

### **Throws:**
This method can throw the next exceptions:

- **WrongDatatypeException**: If api version is not a String or number (can be undefined)
- **WrongFilePathException**: If the package or destructive files path is not a String or cant convert to absolute path
- **FileNotFoundException**: If the package or destructive files path not exists or not have access to it
- **InvalidFilePathException**: If the package or destructive files path is not a file
- **WrongDirectoryPathException**: If the output Folder is not a String or cant convert to absolute path
- **DirectoryNotFoundException**: If the directory not exists or not have access to it
- **InvalidDirectoryPathException**: If the path is not a directory
- **WrongFormatException**: If file is not a JSON file or not have the correct Metadata JSON format

### **Examples:**
You have several options to create the XML after destructive file:

**Create Destructive Changes XML after deploy from Metadata JSON File**

    const PackageGenerator = require('@ah/package-generator');
    const jsonFilePath = 'path/to/json/metadata.json';
    const outputFolder = 'path/to/the/output/folder';
    const options = {
        apiVersion: '50.0',      // Required for create Package from JSON
        explicit: true,          // true to put all element names explicit in package, false to use wildcards if apply. (recommended explicit=true)
    }

    const packageFromFileResult = PackageGenerator.createAfterDeployDestructive(jsonFilePath, outputFolder, options);

    console.log(packageFromFileResult);          // [rootPath]/path/to/json/destructiveChangesPost.xml

**Create Destructive Changes XML after deploy from Metadata JSON Object**

    const PackageGenerator = require('@ah/package-generator');
    const jsonFilePath = 'path/to/json/metadata.json';
    const outputFolder = 'path/to/the/output/folder';
    const options = {
        apiVersion: '50.0',      // Required for create Package from JSON
        explicit: true,          // true to put all element names explicit in package, false to use wildcards if apply. (recommended explicit=true)
    }

    const jsonContent = JSON.parse(fs.readFileSync('jsonFilePath', 'utf8'));
    const packageFromJSONObjectResult = PackageGenerator.createAfterDeployDestructive(jsonContent, outputFolder, options);

    console.log(packageFromJSONObjectResult);          // [rootPath]/path/to/json/destructiveChangesPost.xml
---
## [**validateJSON(metadataOrPath)**](#validatejsonmetadataorpath)
Method to validate a Metadata JSON file or Metadata JSON Object format. If is not valid, throw several exceptions. See [Metadata JSON Format](#metadata-file) section to understand the JSON Metadata File. 

### **Parameters:**
  - **metadataOrPath**: Metadata JSON file or Metadata JSON object to validate.
    - String | Object 

### **Throws:**
This method can throw the next exceptions:

- **WrongFilePathException**: If the package or destructive files path is not a String or cant convert to absolute path
- **FileNotFoundException**: If the package or destructive files path not exists or not have access to it
- **InvalidFilePathException**: If the package or destructive files path is not a file
- **WrongFormatException**: If file is not a JSON file or not have the correct Metadata JSON format

### **Example:**
**Create and Validate your own JSON File**

You can create your own JSON file to create package files and handle metadata types easy with the MetadataType, MetadataObject and MetadataItem classes from [@ah/core](https://github.com/JJLongoria/aura-helper-core). See [Metadata JSON Format](#metadata-file) section to understand the JSON Metadata File. 

    const PackageGenerator = require('@ah/package-generator');
    const { MetadataType, MetadataObject, MetadataItem } = require('@ah/core').Types;

    // Instance a Metadata Type
    const customObjectType = new MetadataType('CustomObject', checkedOrNot, '.../force-app/main/default/objects', 'object');

    // Add Childs to the Metadata Type
    customObjectType.addChild('Account', new MetadataObject('Account', checkedOrNot, '.../force-app/main/default/objects/Account/Account.object-meta.xml'));
    customObjectType.addChild('Case', new MetadataObject('Case', checkedOrNot, '.../force-app/main/default/objects/Case/Case.object-meta.xml'));
    customObjectType.addChild('CustomObject__c', new MetadataObject('CustomObject__c', checkedOrNot, '.../force-app/main/default/objects/CustomObject__c/CustomObject__c.object-meta.xml'));

    // Instance other Metadata Type
    const customFieldType = new MetadataType('CustomField', checkedOrNot, '.../force-app/main/default/objects', 'field');

    // Add child to the Metadata Type
    customFieldType.addChild('Account', new MetadataObject('Account', checkedOrNot, '.../force-app/main/default/objects/Account'));
    
    // Add childs to the Metadata Object
    customFieldType.getChild('Account').addChild('Name', new MetadataItem('Name', checkedOrNot, '.../force-app/main/default/objects/Account/fields/Name.field-meta.xml'));
    customFieldType.getChild('Account').addChild('CustomField__c', new MetadataItem('CustomField__c', checkedOrNot, '.../force-app/main/default/objects/Account/fields/CustomField__c.field-meta.xml'));

    // Add child to the Metadata Type
    customFieldType.addChild('Case', new MetadataObject('Case', checkedOrNot, '.../force-app/main/default/objects/Case'));

    // Add childs to the Metadata Object
    customFieldType.getChild('Case').addChild('Subject', new MetadataItem('Subject', checkedOrNot, '.../force-app/main/default/objects/Case/fields/Subject.field-meta.xml'));
    customFieldType.getChild('Case').addChild('CustomField__c', new MetadataItem('CustomField__c', checkedOrNot, '.../force-app/main/default/objects/Case/fields/CustomField__c.field-meta.xml'));

    // Add the MetadataTypes to the main Object
    const metadataJSON = {
        CustomObject: customObjectType,
        CustomField: customFieldType
    };

    
    // Now you can create a package XML or validate the created object to ensure that is correct.
    try{
        PackageGenerator.validateJSON(metadataJSON);
    } catch(error){
        // JSON is not valid
        console.log(error.message);     // Description about the error
    }

    // Also you can validate directly a JSON file
    try{
        PackageGenerator.validateJSON('path/to/the/json/metadata');
    } catch(error){
        // JSON is not valid
        console.log(error.message);     // Description about the error
    }

# [**Ignore metadata from your package**](#ignore-metadata-from-your-package)
All methods to create or merge package or destructive XML files has two important options to ignore XML files. To ignore files, you need to create a .ahignore.json file (the name can be different) with the format specified on [Ignore File](#ignore-file) section.

### **Examples**:
**Ignore Metadata from a Metadata JSON file when create a package**

    const PackageGenerator = require('@ah/package-generator');
    
    const jsonFilePath = 'path/to/json/metadata.json';
    const outputFolder = 'path/to/the/output/folder';
    const options = {
        apiVersion: '50.0',                 // Required for create Package from JSON
        explicit: true,                     // true to put all element names explicit in package, false to use wildcards if apply. (recommended explicit=true)
        ignoreFile: 'path/to/file'          // Path to the JSON file with the ahignore format with the metadata to exclude
        typesToIgnore: ['CustomObject']     // Optional parameter to ignore metadata. This parameter is used to ignore only the specified metadata on it (also must 
                                            // be in ignore file) and avoid ignore all metadata types specified on the file. For example, you have an ignore file
                                            // with CustomObjects, CustomFields and CustomLabels and you only need to ignore the CustomObjects.
    }

    const packageFromFileResult = PackageGenerator.createPackage(jsonFilePath, outputFolder, options);

    console.log(packageFromFileResult);                    // [rootPath]/path/to/json/package.xml

**Ignore Metadata from a Metadata JSON Object when create a package**

    const PackageGenerator = require('@ah/package-generator');
    
    const jsonFilePath = 'path/to/json/metadata.json';
    const outputFolder = 'path/to/the/output/folder';
    const options = {
        apiVersion: '50.0',                 // Required for create Package from JSON
        explicit: true,                     // true to put all element names explicit in package, false to use wildcards if apply. (recommended explicit=true)
        ignoreFile: 'path/to/file'          // Path to the JSON file with the ahignore format with the metadata to exclude
        typesToIgnore: ['CustomObject']     // Optional parameter to ignore metadata. This parameter is used to ignore only the specified metadata on it (also must 
                                            // be in ignore file) and avoid ignore all metadata types specified on the file. For example, you have an ignore file
                                            // with CustomObjects, CustomFields and CustomLabels and you only need to ignore the CustomObjects.
    }

    const jsonContent = JSON.parse(fs.readFileSync('jsonFilePath', 'utf8'));
    const packageFromJSONObjectResult = PackageGenerator.createPackage(jsonContent, outputFolder, options);

    console.log(packageFromJSONObjectResult);                    // [rootPath]/path/to/json/package.xml

# [**Metadata JSON Format**](#metadata-file)

The Metadata JSON file used by Aura Helper Framework and modules have the next structure. Some fields are required and the datatypes checked to ensure the correct file structure. 

    {
        "MetadataAPIName": {
            "name": "MetadataAPIName",                                  // Required (String). Contains the Metadata Type API Name (like object Key)
            "checked": false,                                           // Required (Boolean). Field for include this type on package or not
            "path": "path/to/the/metadata/folder",                      // Optional (String). Path to the Metadata Type folder in local project
            "suffix": "fileSuffix",                                     // Optional (String). Metadata File suffix
            "childs": {                                                 // Object with a collection of childs (Field required (JSON Object) but can be an empty object)
                "MetadataObjectName":{
                    "name": "MetadataObjectName",                       // Required (String). Contains the Metadata Object API Name (like object Key)
                    "checked": false,                                   // Required (Boolean). Field for include this object on package or not
                    "path": "path/to/the/metadata/file/or/folder",      // Optional (String). Path to the object file or folder path
                    "childs": {                                         // Object with a collection of childs (Field required (JSON Object) but can be an empty object)
                        "MetadataItemName": {
                            "name": "MetadataItemName",                 // Required (String). Contains the Metadata Item API Name (like object Key)
                            "checked": false,                           // Required (Boolean). Field for include this object on package or not
                            "path": "path/to/the/metadata/file"
                        },
                        "MetadataItemName2": {
                            ...
                        },
                        ...,
                        ...,
                        ...
                    }
                }
                "MetadataObjectName2":{
                   ...
                },
                ...,
                ...,
                ...
            }
        }
    }

### **Example**:

***
    {
        "CustomObject": {
            "name": "CustomObject",
            "checked": false,
            "path":  "path/to/root/project/force-app/main/default/objects",
            "suffix": "object",
            "childs": {
                "Account": {
                    "name": "Account",
                    "checked": true,            // Add Account Object to the package
                    "path": "path/to/root/project/force-app/main/default/objects/Account/Account.object-meta.xml",
                    "childs": {}
                },
                "Case": {
                    "name": "Case",
                    "checked": true,            // Add Case Object to the package
                    "path": "path/to/root/project/force-app/main/default/objects/Case/Case.object-meta.xml",
                    "childs": {}
                },
                ...,
                ...,
                ...
            }
        },
        "CustomField": {
            "name": "CustomField",
            "checked": false,
            "path":  "path/to/root/project/force-app/main/default/objects",
            "suffix": "field",
            "childs": {
                "Account": {
                    "name": "Account",
                    "checked": false,            
                    "path": "path/to/root/project/force-app/main/default/objects/Account/fields",
                    "childs": {
                        "customField__c": {
                            "name": "customField__c",
                            "checked": true,    // Add customField__c to the package
                            "path": "path/to/root/project/force-app/main/default/objects/Account/fields/customField__c.field-meta.xml",
                        },
                        ...,
                        ...,
                        ...
                    }
                },
                "Case": {
                    "name": "Case",
                    "checked": false,           
                    "path": "path/to/root/project/force-app/main/default/objects/Case/fields",
                    "childs": {
                        "CaseNumber": {
                            "name": "CaseNumber",
                            "checked": true,    // Add CaseNumber to the package
                            "path": "path/to/root/project/force-app/main/default/objects/Account/fields/CaseNumber.field-meta.xml",
                        },
                        ...,
                        ...,
                        ...
                    }
                },
                ...,
                ...,
                ...
            }
        }
    }

# [**Ignore File**](#ignore-file)

The ignore file is a JSON file used on ignore, create package or repair dependencies modules. On this file you can specify metadata types, objects and elements for ignore or delete from your local project or package files. You can have a main ignore file on your root project (like gitignore) named .ahignore.json for use automatically, or have different ignore files and specify it on the commands when you need tou use.

The ignore file have the next structure

    {
        // Basic structure
        "MetadataTypeAPIName": {
            "MetadataObject1",
            "MetadataObject2"
        }

        // Advance Structure
        "MetadataTypeAPIName": {
            "MetadataObject1:MetadataItem1",
            "MetadataObject1:MetadataItem2",
            "MetadataObject2:*",
            "*",
            "*:*" // Only valid on Custom Objects
        }

        // Special for Permissions
        "MetadataTypeAPIName": {
            "UserPermission:MetadataObject1:PermissionName",
            "UserPermission:MetadataObject2:*",
            "UserPermission:*:PermissionName"
        }
    }

### **Example**:

    {
        "CustomLabels": {
            "labelName1",                   // Ignore or remove the custom label "labelName1"
            "labelName2",                   // Ignore or remove the custom label "labelName2",
            "*"                             // Ignore or remove all Custom Labels
        },
        "AssignmentRules":{
            "Case:Assign1",                 // Ignore or remove the Assignent Rule "Assign1" from the object Case
            "Lead:*",                       // Ignore or remove all Assignment Rules from Lead
            "*"                             // Ignore or remove all Assignment Rules
        },
        "CustomObject": {
            "Account",                      // Ignore or remove the Account Object
            "Case:*",                       // Ignore or remove all related objects from case, including the object (Bussines Process, Fields, Validation Rules...),
            "*",                            // Ignore or remove all custom objects (only the object not the related metadata)
            "*:*",                          // Ignore or remove all custom objects and the related metadata (Bussines Process, Fields, Validation Rules...)
        },
        "Report": {
            "ReportFolder",                 // Ignore or remove the entire folder
            "ReportFolder1:ReportName2",    // Ignore or remove the report "ReportName2" from "ReportFolder1" folder.
            "*",                            // Ignore or remove all reports.
        },
        "Workflow": {
            "Account",                      // Ignore or remove the Account worflows (Rules, Task, Alerts...)
            "*"                             // Ignore or  remove all workflows (Rules, Task, Alerts...) from all objects 
        },
        "WorkflowRule": {
            "Case:*",                       // Ignore or remove all Workflow rules from case object
            "Account:Rule1",                // Ignore or remove "Rule1" from Account workflows,
            "*"                             // Ignore or remove all Worflow rules from all objects
        },
        "Profile": {
            "UserPermission:*:Permission1", // Remove the "Permission1" User Permission from all profiles
            "UserPermission:TestProfile:*", // Remove all User permissions from TestProfile file
            "UserPermission:Admin:Perm1",   // Remove the Perm1 User Permission from Admin profile
            "TestProfile2",                 // Ignore or remove  the "TestProfile" profile 
            "*"                             // Ignore or remove all profiles
        }
    }

#### **IMPORTANT**

Some Metadata Types have singular and plural name like CustomLabels, MatchingRules, EscalationRules... For ignore or remove this types you must use the plural name, if use the singular name the ignore process not take effect with this types.